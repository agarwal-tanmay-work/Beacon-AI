[{"filePath":"C:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\app\\page.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ShieldCheck' is defined but never used.","line":199,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":199,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8684,8687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8684,8687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\n\nimport React, { useRef, useMemo } from \"react\";\nimport { InteractiveHoverButton } from \"@/components/ui/interactive-hover-button\";\nimport VaporizeTextCycle, { Tag } from \"@/components/ui/vapour-text-effect\";\nimport { PulseBeams } from \"@/components/ui/pulse-beams\";\nimport { FireSphere } from \"@/components/ui/fire-sphere\";\nimport { SparklesCore } from \"@/components/ui/sparkles\";\nimport { FAQSection } from \"@/components/ui/faq-section\";\nimport { FileLock2 } from \"lucide-react\";\n\nexport default function Home() {\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // Define beams for the connectivity section\n  const beams = [\n    {\n      path: \"M42.5 220.5H16.5C10.9772 220.5 6.5 224.977 6.5 230.5V398.5\",\n      gradientConfig: {\n        initial: { x1: \"0%\", x2: \"0%\", y1: \"80%\", y2: \"100%\" },\n        animate: { x1: [\"0%\", \"0%\", \"200%\"], x2: [\"0%\", \"0%\", \"180%\"], y1: [\"80%\", \"0%\", \"0%\"], y2: [\"100%\", \"20%\", \"20%\"] },\n        transition: { duration: 2, repeat: Infinity, repeatType: \"loop\", ease: \"linear\", repeatDelay: 0.5 },\n      },\n      connectionPoints: [{ cx: 6.5, cy: 398.5, r: 4 }]\n    },\n    {\n      path: \"M200 100 H400 V300 H600\",\n      gradientConfig: {\n        initial: { x1: \"0%\", x2: \"0%\", y1: \"0%\", y2: \"0%\" },\n        animate: { x1: [\"0%\", \"100%\"], x2: [\"0%\", \"90%\"], y1: \"0%\", y2: \"0%\" },\n        transition: { duration: 3, repeat: Infinity, repeatType: \"loop\", ease: \"linear\" },\n      }\n    }\n  ];\n\n  return (\n    <div className=\"w-full relative bg-black text-white selection:bg-purple-500/30 overflow-hidden\" ref={containerRef}>\n\n      {/* --- HERO SECTION --- */}\n      <section className=\"relative h-screen w-full flex flex-col justify-center items-center overflow-hidden bg-black\">\n\n        <div className=\"relative z-20 flex flex-col items-center justify-center space-y-8 px-4 w-full max-w-5xl mx-auto pt-20\">\n\n          <div className=\"flex flex-col items-center justify-center\">\n            <div className=\"relative h-48 md:h-64 w-full flex flex-col items-center justify-center overflow-hidden rounded-md z-30\">\n              <VaporizeTextCycle\n                texts={useMemo(() => [\"Beacon AI\"], [])}\n                font={useMemo(() => ({\n                  fontFamily: \"Inter, sans-serif\",\n                  fontSize: \"100px\",\n                  fontWeight: 800,\n                }), [])}\n                color=\"rgba(255, 255, 255, 1)\"\n                spread={5}\n                density={5}\n                animation={useMemo(() => ({\n                  vaporizeDuration: 2,\n                  fadeInDuration: 1,\n                  waitDuration: 0.5,\n                }), [])}\n                direction=\"left-to-right\"\n                alignment=\"center\"\n                tag={Tag.H1}\n              />\n            </div>\n\n            {/* Acme-style Sparkles Horizon */}\n            <div className=\"w-[40rem] h-40 relative mt-[-60px] z-10\">\n              {/* Gradients */}\n              <div className=\"absolute inset-x-20 top-0 bg-gradient-to-r from-transparent via-indigo-500 to-transparent h-[2px] w-3/4 blur-sm\" />\n              <div className=\"absolute inset-x-20 top-0 bg-gradient-to-r from-transparent via-indigo-500 to-transparent h-px w-3/4\" />\n              <div className=\"absolute inset-x-60 top-0 bg-gradient-to-r from-transparent via-sky-500 to-transparent h-[5px] w-1/4 blur-sm\" />\n              <div className=\"absolute inset-x-60 top-0 bg-gradient-to-r from-transparent via-sky-500 to-transparent h-px w-1/4\" />\n\n              {/* Core component */}\n              <SparklesCore\n                background=\"transparent\"\n                minSize={0.4}\n                maxSize={1}\n                particleDensity={800}\n                className=\"w-full h-full\"\n                particleColor=\"#FFFFFF\"\n              />\n\n              {/* Radial Gradient to prevent sharp edges */}\n              <div className=\"absolute inset-0 w-full h-full bg-black [mask-image:radial-gradient(350px_200px_at_top,transparent_20%,white)]\"></div>\n            </div>\n          </div>\n\n          <p className=\"text-xl md:text-2xl text-white/70 text-center max-w-2xl leading-relaxed font-light z-20\">\n            Secure, anonymous corruption reporting powered by government-grade AI analysis.\n          </p>\n\n          <div className=\"flex gap-6 mt-8 z-20\">\n            <a href=\"/report\">\n              <InteractiveHoverButton text=\"Start Report\" className=\"w-40 bg-white text-black hover:bg-white/90\" />\n            </a>\n            <a href=\"/track\">\n              <InteractiveHoverButton text=\"Track Status\" className=\"w-40 bg-white/10 text-white border-white/20 hover:bg-white/20\" />\n            </a>\n          </div>\n        </div>\n      </section>\n\n\n      {/* --- INTEGRITY / PROCESS SECTION (Was Forensic Verification) --- */}\n      <section className=\"relative w-full py-24 bg-black overflow-hidden\">\n        <SparklesCore\n          id=\"tsparticlesfull\"\n          background=\"transparent\"\n          minSize={0.6}\n          maxSize={1.4}\n          particleDensity={50}\n          className=\"absolute inset-0 z-0 opacity-50\"\n          particleColor=\"#FFFFFF\"\n        />\n\n        <div className=\"container mx-auto px-4 relative z-10 grid md:grid-cols-2 gap-12 items-center\">\n\n          {/* Left: Component - Data/Document Verification */}\n          <div className=\"h-[500px] w-full relative rounded-3xl border border-white/10 bg-white/5 overflow-hidden backdrop-blur-sm group\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-blue-500/5 to-purple-500/5 group-hover:opacity-100 transition-opacity duration-1000\" />\n\n            {/* Pulse Beams Visualization - Abstract Data Flow */}\n            <PulseBeams\n              beams={beams}\n              className=\"w-full h-full absolute inset-0 opacity-60\"\n            >\n              <div className=\"w-full h-full flex items-center justify-center\">\n                <div className=\"bg-black/80 backdrop-blur-xl p-4 rounded-full border border-white/10 z-20\">\n                  <FileLock2 className=\"w-12 h-12 text-white/80\" />\n                </div>\n              </div>\n            </PulseBeams>\n          </div>\n\n          {/* Right: Institutional Text */}\n          <div className=\"space-y-8\">\n            <h2 className=\"text-4xl md:text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-white to-white/60\">\n              Automated Integrity.\n            </h2>\n            <div className=\"space-y-6\">\n              <div className=\"flex flex-col gap-2\">\n                <h3 className=\"text-xl font-semibold text-white/90\">Submission Processing</h3>\n                <p className=\"text-lg text-white/60 leading-relaxed font-light\">\n                  All reports are cryptographically secured and routed through our automated verification pipeline.\n                  User identity remains strictly anonymous.\n                </p>\n              </div>\n\n              <div className=\"w-full h-px bg-white/10\" />\n\n              <div className=\"flex flex-col gap-2\">\n                <h3 className=\"text-xl font-semibold text-white/90\">Evidence Validation</h3>\n                <p className=\"text-lg text-white/60 leading-relaxed font-light\">\n                  Uploaded assets undergo metadata analysis to ensure authenticity before being added to the case file.\n                </p>\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n\n      {/* --- TECH CORE --- */}\n      <section className=\"relative w-full h-[80vh] bg-black flex flex-col items-center justify-center overflow-hidden\">\n        <div className=\"absolute inset-0 z-0\">\n          <FireSphere\n            color1={[201, 158, 72]}\n            color0={[74, 30, 0]}\n            bloomStrength={2.0}\n          />\n        </div>\n\n        <div className=\"relative z-10 text-center space-y-4 pointer-events-none\">\n          <h2 className=\"text-5xl md:text-7xl font-bold tracking-tighter text-white drop-shadow-[0_0_25px_rgba(255,255,255,0.5)]\">\n            INTEGRITY CORE\n          </h2>\n          <p className=\"text-xl text-blue-200/80 tracking-widest font-mono uppercase\">\n            SYSTEM ACTIVE\n          </p>\n        </div>\n      </section>\n\n      {/* --- FAQ / TRUST --- */}\n      <FAQSection />\n\n      {/* --- FOOTER --- */}\n      <footer className=\"w-full py-12 px-6 border-t border-white/10 bg-black/95 backdrop-blur-xl relative z-20\">\n        <div className=\"container mx-auto flex flex-col md:flex-row justify-between items-center text-white/30 text-sm\">\n          <p>&copy; 2026 Beacon AI</p>\n          <p className=\"font-mono mt-4 md:mt-0 opacity-70\">Secure. Anonymous. Verified.</p>\n        </div>\n      </footer>\n\n    </div>\n  );\n}\n\nfunction ShieldCheck(props: any) {\n  return (\n    <svg\n      {...props}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path d=\"M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z\" />\n      <path d=\"m9 12 2 2 4-4\" />\n    </svg>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\components\\ui\\vapour-text-effect.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'alignment', 'color', 'currentTextIndex', 'font', 'globalDpr', 'texts', and 'transformedDensity'. Either include them or remove the dependency array. Mutable values like 'wrapperRef.current' aren't valid dependencies because mutating them doesn't re-render the component.","line":342,"column":8,"nodeType":"ArrayExpression","endLine":342,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [alignment, color, currentTextIndex, font, globalDpr, texts, transformedDensity]","fix":{"range":[11952,11972],"text":"[alignment, color, currentTextIndex, font, globalDpr, texts, transformedDensity]"}}]},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\nC:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\components\\ui\\vapour-text-effect.tsx:342:9\n  340 |             resizeObserver.disconnect();\n  341 |         };\n> 342 |     }, [wrapperRef.current]);\n      |         ^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  343 |\n  344 |     // Initial size detection\n  345 |     useEffect(() => {","line":342,"column":9,"nodeType":null,"endLine":342,"endColumn":27},{"ruleId":"react-hooks/refs","severity":2,"message":"Error: Cannot access refs during render\n\nReact refs are values that are not needed for rendering. Refs should only be accessed outside of render, such as in event handlers or effects. Accessing a ref value (the `current` property) during render can cause your component not to update as expected (https://react.dev/reference/react/useRef).\n\nC:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\components\\ui\\vapour-text-effect.tsx:342:9\n  340 |             resizeObserver.disconnect();\n  341 |         };\n> 342 |     }, [wrapperRef.current]);\n      |         ^^^^^^^^^^^^^^^^^^ Cannot access ref value during render\n  343 |\n  344 |     // Initial size detection\n  345 |     useEffect(() => {","line":342,"column":9,"nodeType":null,"endLine":342,"endColumn":27},{"ruleId":"react/display-name","severity":2,"message":"Component definition is missing display name","line":366,"column":20,"nodeType":"CallExpression","messageId":"noDisplayName","endLine":380,"endColumn":3},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transformedDensity' is defined but never used.","line":460,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":460,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":537,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":537,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18196,18199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18196,18199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":541,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":541,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18286,18289],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18286,18289],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used.","line":771,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":771,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used.","line":775,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":775,"endColumn":17}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport React, { useRef, useEffect, useState, createElement, useMemo, useCallback, memo } from \"react\";\r\n\r\nexport enum Tag {\r\n    H1 = \"h1\",\r\n    H2 = \"h2\",\r\n    H3 = \"h3\",\r\n    P = \"p\",\r\n}\r\n\r\ntype VaporizeTextCycleProps = {\r\n    texts: string[];\r\n    font?: {\r\n        fontFamily?: string;\r\n        fontSize?: string;\r\n        fontWeight?: number;\r\n    };\r\n    color?: string;\r\n    spread?: number;\r\n    density?: number;\r\n    animation?: {\r\n        vaporizeDuration?: number;\r\n        fadeInDuration?: number;\r\n        waitDuration?: number;\r\n    };\r\n    direction?: \"left-to-right\" | \"right-to-left\";\r\n    alignment?: \"left\" | \"center\" | \"right\";\r\n    tag?: Tag;\r\n};\r\n\r\ntype Particle = {\r\n    x: number;\r\n    y: number;\r\n    originalX: number;\r\n    originalY: number;\r\n    color: string;\r\n    opacity: number;\r\n    originalAlpha: number;\r\n    velocityX: number;\r\n    velocityY: number;\r\n    angle: number;\r\n    speed: number;\r\n    shouldFadeQuickly?: boolean;\r\n};\r\n\r\ntype TextBoundaries = {\r\n    left: number;\r\n    right: number;\r\n    width: number;\r\n};\r\n\r\ndeclare global {\r\n    interface HTMLCanvasElement {\r\n        textBoundaries?: TextBoundaries;\r\n    }\r\n}\r\n\r\nexport default function VaporizeTextCycle({\r\n    texts = [\"Next.js\", \"React\"],\r\n    font = {\r\n        fontFamily: \"sans-serif\",\r\n        fontSize: \"50px\",\r\n        fontWeight: 400,\r\n    },\r\n    color = \"rgb(255, 255, 255)\",\r\n    spread = 5,\r\n    density = 5,\r\n    animation = {\r\n        vaporizeDuration: 2,\r\n        fadeInDuration: 1,\r\n        waitDuration: 0.5,\r\n    },\r\n    direction = \"left-to-right\",\r\n    alignment = \"center\",\r\n    tag = Tag.P,\r\n}: VaporizeTextCycleProps) {\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n    const wrapperRef = useRef<HTMLDivElement | null>(null);\r\n    const isInView = useIsInView(wrapperRef as React.RefObject<HTMLElement>);\r\n    const lastFontRef = useRef<string | null>(null);\r\n    const particlesRef = useRef<Particle[]>([]);\r\n    const animationFrameRef = useRef<number | null>(null);\r\n    const [currentTextIndex, setCurrentTextIndex] = useState(0);\r\n    const [animationState, setAnimationState] = useState<\"static\" | \"vaporizing\" | \"fadingIn\" | \"waiting\">(\"static\");\r\n    const vaporizeProgressRef = useRef(0);\r\n    const fadeOpacityRef = useRef(0);\r\n    const [wrapperSize, setWrapperSize] = useState({ width: 0, height: 0 });\r\n    const transformedDensity = transformValue(density, [0, 10], [0.3, 1], true);\r\n\r\n    // Calculate device pixel ratio\r\n    const globalDpr = useMemo(() => {\r\n        if (typeof window !== \"undefined\") {\r\n            return window.devicePixelRatio * 1.5 || 1;\r\n        }\r\n        return 1;\r\n    }, []);\r\n\r\n    // Memoize static styles\r\n    const wrapperStyle = useMemo(() => ({\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        pointerEvents: \"none\" as const,\r\n        position: \"relative\" as const,\r\n    }), []);\r\n\r\n    const canvasStyle = useMemo(() => ({\r\n        minWidth: \"30px\",\r\n        minHeight: \"20px\",\r\n        pointerEvents: \"none\" as const,\r\n    }), []);\r\n\r\n    // Memoize animation durations\r\n    const animationDurations = useMemo(() => ({\r\n        VAPORIZE_DURATION: (animation.vaporizeDuration ?? 2) * 1000,\r\n        FADE_IN_DURATION: (animation.fadeInDuration ?? 1) * 1000,\r\n        WAIT_DURATION: (animation.waitDuration ?? 0.5) * 1000,\r\n    }), [animation.vaporizeDuration, animation.fadeInDuration, animation.waitDuration]);\r\n\r\n    // Memoize font and spread calculations\r\n    const fontConfig = useMemo(() => {\r\n        const fontSize = parseInt(font.fontSize?.replace(\"px\", \"\") || \"50\");\r\n        const VAPORIZE_SPREAD = calculateVaporizeSpread(fontSize);\r\n        const MULTIPLIED_VAPORIZE_SPREAD = VAPORIZE_SPREAD * spread;\r\n        return {\r\n            fontSize,\r\n            VAPORIZE_SPREAD,\r\n            MULTIPLIED_VAPORIZE_SPREAD,\r\n            font: `${font.fontWeight ?? 400} ${fontSize * globalDpr}px ${font.fontFamily}`,\r\n        };\r\n    }, [font.fontSize, font.fontWeight, font.fontFamily, spread, globalDpr]);\r\n\r\n    // Memoize particle update function\r\n    const memoizedUpdateParticles = useCallback((particles: Particle[], vaporizeX: number, deltaTime: number) => {\r\n        return updateParticles(\r\n            particles,\r\n            vaporizeX,\r\n            deltaTime,\r\n            fontConfig.MULTIPLIED_VAPORIZE_SPREAD,\r\n            animationDurations.VAPORIZE_DURATION,\r\n            direction,\r\n            transformedDensity\r\n        );\r\n    }, [fontConfig.MULTIPLIED_VAPORIZE_SPREAD, animationDurations.VAPORIZE_DURATION, direction, transformedDensity]);\r\n\r\n    // Memoize render function\r\n    const memoizedRenderParticles = useCallback((ctx: CanvasRenderingContext2D, particles: Particle[]) => {\r\n        renderParticles(ctx, particles, globalDpr);\r\n    }, [globalDpr]);\r\n\r\n    // Start animation cycle when in view\r\n    useEffect(() => {\r\n        if (isInView) {\r\n            const startAnimationTimeout = setTimeout(() => {\r\n                setAnimationState(\"vaporizing\");\r\n            }, 0);\r\n            return () => clearTimeout(startAnimationTimeout);\r\n        } else {\r\n            // When component goes out of view, reset to static state\r\n            setAnimationState(\"static\");\r\n            if (animationFrameRef.current) {\r\n                cancelAnimationFrame(animationFrameRef.current);\r\n                animationFrameRef.current = null;\r\n            }\r\n        }\r\n    }, [isInView]);\r\n\r\n    // Animation loop - only run when in view\r\n    useEffect(() => {\r\n        if (!isInView) return;\r\n\r\n        let lastTime = performance.now();\r\n        let frameId: number;\r\n\r\n        const animate = (currentTime: number) => {\r\n            const deltaTime = (currentTime - lastTime) / 1000;\r\n            lastTime = currentTime;\r\n\r\n            const canvas = canvasRef.current;\r\n            const ctx = canvas?.getContext(\"2d\");\r\n\r\n            if (!canvas || !ctx || !particlesRef.current.length) {\r\n                frameId = requestAnimationFrame(animate);\r\n                return;\r\n            }\r\n\r\n            // Clear canvas only if we're going to draw\r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            // Update based on animation state\r\n            switch (animationState) {\r\n                case \"static\": {\r\n                    memoizedRenderParticles(ctx, particlesRef.current);\r\n                    break;\r\n                }\r\n                case \"vaporizing\": {\r\n                    // Calculate progress based on duration\r\n                    vaporizeProgressRef.current += deltaTime * 100 / (animationDurations.VAPORIZE_DURATION / 1000);\r\n\r\n                    // Get text boundaries\r\n                    const textBoundaries = canvas.textBoundaries;\r\n                    if (!textBoundaries) break;\r\n\r\n                    // Calculate vaporize position based on text boundaries and direction\r\n                    const progress = Math.min(100, vaporizeProgressRef.current);\r\n                    const vaporizeX = direction === \"left-to-right\"\r\n                        ? textBoundaries.left + textBoundaries.width * progress / 100\r\n                        : textBoundaries.right - textBoundaries.width * progress / 100;\r\n\r\n                    const allVaporized = memoizedUpdateParticles(particlesRef.current, vaporizeX, deltaTime);\r\n                    memoizedRenderParticles(ctx, particlesRef.current);\r\n\r\n                    // Check if vaporization is complete\r\n                    if (vaporizeProgressRef.current >= 100 && allVaporized) {\r\n                        setCurrentTextIndex(prevIndex => (prevIndex + 1) % texts.length);\r\n                        setAnimationState(\"fadingIn\");\r\n                        fadeOpacityRef.current = 0;\r\n                    }\r\n                    break;\r\n                }\r\n                case \"fadingIn\": {\r\n                    fadeOpacityRef.current += deltaTime * 1000 / animationDurations.FADE_IN_DURATION;\r\n\r\n                    // Use particles for fade-in\r\n                    ctx.save();\r\n                    ctx.scale(globalDpr, globalDpr);\r\n                    particlesRef.current.forEach(particle => {\r\n                        particle.x = particle.originalX;\r\n                        particle.y = particle.originalY;\r\n                        const opacity = Math.min(fadeOpacityRef.current, 1) * particle.originalAlpha;\r\n                        const color = particle.color.replace(/[\\d.]+\\)$/, `${opacity})`);\r\n                        ctx.fillStyle = color;\r\n                        ctx.fillRect(particle.x / globalDpr, particle.y / globalDpr, 1, 1);\r\n                    });\r\n                    ctx.restore();\r\n\r\n                    if (fadeOpacityRef.current >= 1) {\r\n                        setAnimationState(\"waiting\");\r\n                        setTimeout(() => {\r\n                            setAnimationState(\"vaporizing\");\r\n                            vaporizeProgressRef.current = 0;\r\n                            resetParticles(particlesRef.current);\r\n                        }, animationDurations.WAIT_DURATION);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"waiting\": {\r\n                    memoizedRenderParticles(ctx, particlesRef.current);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            frameId = requestAnimationFrame(animate);\r\n        };\r\n\r\n        frameId = requestAnimationFrame(animate);\r\n\r\n        return () => {\r\n            if (frameId) {\r\n                cancelAnimationFrame(frameId);\r\n            }\r\n        };\r\n    }, [\r\n        animationState,\r\n        isInView,\r\n        texts.length,\r\n        direction,\r\n        globalDpr,\r\n        memoizedUpdateParticles,\r\n        memoizedRenderParticles,\r\n        animationDurations.FADE_IN_DURATION,\r\n        animationDurations.WAIT_DURATION,\r\n        animationDurations.VAPORIZE_DURATION\r\n    ]);\r\n\r\n    useEffect(() => {\r\n        renderCanvas({\r\n            framerProps: {\r\n                texts,\r\n                font,\r\n                color,\r\n                alignment,\r\n            },\r\n            canvasRef: canvasRef as React.RefObject<HTMLCanvasElement>,\r\n            wrapperSize,\r\n            particlesRef,\r\n            globalDpr,\r\n            currentTextIndex,\r\n            transformedDensity,\r\n        });\r\n\r\n        const currentFont = font.fontFamily || \"sans-serif\";\r\n        return handleFontChange({\r\n            currentFont,\r\n            lastFontRef,\r\n            canvasRef: canvasRef as React.RefObject<HTMLCanvasElement>,\r\n            wrapperSize,\r\n            particlesRef,\r\n            globalDpr,\r\n            currentTextIndex,\r\n            transformedDensity,\r\n            framerProps: {\r\n                texts,\r\n                font,\r\n                color,\r\n                alignment,\r\n            },\r\n        });\r\n    }, [texts, font, color, alignment, wrapperSize, currentTextIndex, globalDpr, transformedDensity]);\r\n\r\n    // Handle resize\r\n    useEffect(() => {\r\n        const container = wrapperRef.current;\r\n        if (!container) return;\r\n\r\n        const resizeObserver = new ResizeObserver(entries => {\r\n            for (const entry of entries) {\r\n                const { width, height } = entry.contentRect;\r\n                setWrapperSize({ width, height });\r\n            }\r\n\r\n            renderCanvas({\r\n                framerProps: {\r\n                    texts,\r\n                    font,\r\n                    color,\r\n                    alignment,\r\n                },\r\n                canvasRef: canvasRef as React.RefObject<HTMLCanvasElement>,\r\n                wrapperSize: { width: container.clientWidth, height: container.clientHeight },\r\n                particlesRef,\r\n                globalDpr,\r\n                currentTextIndex,\r\n                transformedDensity,\r\n            });\r\n        });\r\n\r\n        resizeObserver.observe(container);\r\n        return () => {\r\n            resizeObserver.disconnect();\r\n        };\r\n    }, [wrapperRef.current]);\r\n\r\n    // Initial size detection\r\n    useEffect(() => {\r\n        if (wrapperRef.current) {\r\n            const rect = wrapperRef.current.getBoundingClientRect();\r\n            setWrapperSize({\r\n                width: rect.width,\r\n                height: rect.height,\r\n            });\r\n        }\r\n    }, []);\r\n\r\n    return (\r\n        <div ref={wrapperRef} style={wrapperStyle}>\r\n            <canvas ref={canvasRef} style={canvasStyle} />\r\n            <SeoElement tag={tag} texts={texts} />\r\n        </div>\r\n    );\r\n}\r\n\r\n// ------------------------------------------------------------ //\r\n// SEO ELEMENT\r\n// ------------------------------------------------------------ //\r\nconst SeoElement = memo(({ tag = Tag.P, texts }: { tag: Tag, texts: string[] }) => {\r\n    const style = useMemo(() => ({\r\n        position: \"absolute\" as const,\r\n        width: \"0\",\r\n        height: \"0\",\r\n        overflow: \"hidden\",\r\n        userSelect: \"none\" as const,\r\n        pointerEvents: \"none\" as const,\r\n    }), []);\r\n\r\n    // Ensure tag is a valid HTML element string\r\n    const safeTag = Object.values(Tag).includes(tag) ? tag : \"p\";\r\n\r\n    return createElement(safeTag, { style }, texts?.join(\" \") ?? \"\");\r\n});\r\n\r\n// ------------------------------------------------------------ //\r\n// FONT HANDLING\r\n// ------------------------------------------------------------ //\r\nconst handleFontChange = ({\r\n    currentFont,\r\n    lastFontRef,\r\n    canvasRef,\r\n    wrapperSize,\r\n    particlesRef,\r\n    globalDpr,\r\n    currentTextIndex,\r\n    transformedDensity,\r\n    framerProps,\r\n}: {\r\n    currentFont: string;\r\n    lastFontRef: React.MutableRefObject<string | null>;\r\n    canvasRef: React.RefObject<HTMLCanvasElement>;\r\n    wrapperSize: { width: number; height: number };\r\n    particlesRef: React.MutableRefObject<Particle[]>;\r\n    globalDpr: number;\r\n    currentTextIndex: number;\r\n    transformedDensity: number;\r\n    framerProps: VaporizeTextCycleProps;\r\n}) => {\r\n    if (currentFont !== lastFontRef.current) {\r\n        lastFontRef.current = currentFont;\r\n\r\n        // Re-render after 1 second to catch the loaded font\r\n        const timeoutId = setTimeout(() => {\r\n            cleanup({ canvasRef, particlesRef }); // Clean up before re-rendering\r\n            renderCanvas({\r\n                framerProps,\r\n                canvasRef,\r\n                wrapperSize,\r\n                particlesRef,\r\n                globalDpr,\r\n                currentTextIndex,\r\n                transformedDensity,\r\n            });\r\n        }, 1000);\r\n\r\n        return () => {\r\n            clearTimeout(timeoutId);\r\n            cleanup({ canvasRef, particlesRef });\r\n        };\r\n    }\r\n\r\n    return undefined;\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// CLEANUP\r\n// ------------------------------------------------------------ //\r\nconst cleanup = ({ canvasRef, particlesRef }: { canvasRef: React.RefObject<HTMLCanvasElement>; particlesRef: React.MutableRefObject<Particle[]> }) => {\r\n    // Clear canvas\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas?.getContext(\"2d\");\r\n\r\n    if (canvas && ctx) {\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    // Clear particles\r\n    if (particlesRef.current) {\r\n        particlesRef.current = [];\r\n    }\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// RENDER CANVAS\r\n// ------------------------------------------------------------ //\r\nconst renderCanvas = ({\r\n    framerProps,\r\n    canvasRef,\r\n    wrapperSize,\r\n    particlesRef,\r\n    globalDpr,\r\n    currentTextIndex,\r\n    transformedDensity,\r\n}: {\r\n    framerProps: VaporizeTextCycleProps;\r\n    canvasRef: React.RefObject<HTMLCanvasElement>;\r\n    wrapperSize: { width: number; height: number };\r\n    particlesRef: React.MutableRefObject<Particle[]>;\r\n    globalDpr: number;\r\n    currentTextIndex: number;\r\n    transformedDensity: number;\r\n}) => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas || !wrapperSize.width || !wrapperSize.height) return;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    const { width, height } = wrapperSize;\r\n\r\n    // Scale for retina/high DPI displays\r\n    canvas.style.width = `${width}px`;\r\n    canvas.style.height = `${height}px`;\r\n    canvas.width = Math.floor(width * globalDpr);\r\n    canvas.height = Math.floor(height * globalDpr);\r\n\r\n    // Parse font size\r\n    const fontSize = parseInt(framerProps.font?.fontSize?.replace(\"px\", \"\") || \"50\");\r\n    const font = `${framerProps.font?.fontWeight ?? 400} ${fontSize * globalDpr}px ${framerProps.font?.fontFamily ?? \"sans-serif\"}`;\r\n    const color = parseColor(framerProps.color ?? \"rgb(153, 153, 153)\");\r\n\r\n    // Calculate text position\r\n    let textX;\r\n    const textY = canvas.height / 2;\r\n    const currentText = framerProps.texts[currentTextIndex] || \"Next.js\";\r\n\r\n    if (framerProps.alignment === \"center\") {\r\n        textX = canvas.width / 2;\r\n    } else if (framerProps.alignment === \"left\") {\r\n        textX = 0;\r\n    } else {\r\n        textX = canvas.width;\r\n    }\r\n\r\n    // Create particles from the rendered text and get text boundaries\r\n    const { particles, textBoundaries } = createParticles(ctx, canvas, currentText, textX, textY, font, color, framerProps.alignment || \"left\");\r\n\r\n    // Store particles and text boundaries for animation\r\n    particlesRef.current = particles;\r\n    canvas.textBoundaries = textBoundaries;\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// PARTICLE SYSTEM\r\n// ------------------------------------------------------------ //\r\nconst createParticles = (\r\n    ctx: CanvasRenderingContext2D,\r\n    canvas: HTMLCanvasElement,\r\n    text: string,\r\n    textX: number,\r\n    textY: number,\r\n    font: string,\r\n    color: string,\r\n    alignment: \"left\" | \"center\" | \"right\"\r\n) => {\r\n    const particles = [];\r\n\r\n    // Clear any previous content\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Set text properties for sampling\r\n    ctx.fillStyle = color;\r\n    ctx.font = font;\r\n    ctx.textAlign = alignment;\r\n    ctx.textBaseline = \"middle\";\r\n    ctx.imageSmoothingQuality = \"high\";\r\n    ctx.imageSmoothingEnabled = true;\r\n\r\n    if ('fontKerning' in ctx) {\r\n        (ctx as any).fontKerning = \"normal\";\r\n    }\r\n\r\n    if ('textRendering' in ctx) {\r\n        (ctx as any).textRendering = \"geometricPrecision\";\r\n    }\r\n\r\n    // Calculate text boundaries\r\n    const metrics = ctx.measureText(text);\r\n    let textLeft;\r\n    const textWidth = metrics.width;\r\n\r\n    if (alignment === \"center\") {\r\n        textLeft = textX - textWidth / 2;\r\n    } else if (alignment === \"left\") {\r\n        textLeft = textX;\r\n    } else {\r\n        textLeft = textX - textWidth;\r\n    }\r\n\r\n    const textBoundaries = {\r\n        left: textLeft,\r\n        right: textLeft + textWidth,\r\n        width: textWidth,\r\n    };\r\n\r\n    // Render the text for sampling\r\n    ctx.fillText(text, textX, textY);\r\n\r\n    // Sample the rendered text\r\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    const data = imageData.data;\r\n\r\n    // Calculate sampling rate based on DPR and density to maintain consistent particle density\r\n    const baseDPR = 3; // Base DPR we're optimizing for\r\n    const currentDPR = canvas.width / parseInt(canvas.style.width);\r\n    const baseSampleRate = Math.max(1, Math.round(currentDPR / baseDPR));\r\n    const sampleRate = Math.max(1, Math.round(baseSampleRate)); // Adjust sample rate by density\r\n\r\n    // Sample the text pixels and create particles\r\n    for (let y = 0; y < canvas.height; y += sampleRate) {\r\n        for (let x = 0; x < canvas.width; x += sampleRate) {\r\n            const index = (y * canvas.width + x) * 4;\r\n            const alpha = data[index + 3];\r\n\r\n            if (alpha > 0) {\r\n                // Remove density from opacity calculation\r\n                const originalAlpha = alpha / 255 * (sampleRate / currentDPR);\r\n                const particle = {\r\n                    x,\r\n                    y,\r\n                    originalX: x,\r\n                    originalY: y,\r\n                    color: `rgba(${data[index]}, ${data[index + 1]}, ${data[index + 2]}, ${originalAlpha})`,\r\n                    opacity: originalAlpha,\r\n                    originalAlpha,\r\n                    // Animation properties\r\n                    velocityX: 0,\r\n                    velocityY: 0,\r\n                    angle: 0,\r\n                    speed: 0,\r\n                };\r\n\r\n                particles.push(particle);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Clear the canvas after sampling\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    return { particles, textBoundaries };\r\n};\r\n\r\n// Helper functions for particle animation\r\nconst updateParticles = (\r\n    particles: Particle[],\r\n    vaporizeX: number,\r\n    deltaTime: number,\r\n    MULTIPLIED_VAPORIZE_SPREAD: number,\r\n    VAPORIZE_DURATION: number,\r\n    direction: string,\r\n    density: number\r\n) => {\r\n    let allParticlesVaporized = true;\r\n\r\n    particles.forEach(particle => {\r\n        // Only animate particles that have been \"vaporized\"\r\n        const shouldVaporize = direction === \"left-to-right\"\r\n            ? particle.originalX <= vaporizeX\r\n            : particle.originalX >= vaporizeX;\r\n\r\n        if (shouldVaporize) {\r\n            // When a particle is first vaporized, determine if it should fade quickly based on density\r\n            if (particle.speed === 0) {\r\n                // Initialize particle motion when first vaporized\r\n                particle.angle = Math.random() * Math.PI * 2;\r\n                particle.speed = (Math.random() * 1 + 0.5) * MULTIPLIED_VAPORIZE_SPREAD;\r\n                particle.velocityX = Math.cos(particle.angle) * particle.speed;\r\n                particle.velocityY = Math.sin(particle.angle) * particle.speed;\r\n\r\n                // Determine if particle should fade quickly based on density\r\n                // density of 1 means all particles animate normally\r\n                // density of 0.5 means 50% of particles fade quickly\r\n                particle.shouldFadeQuickly = Math.random() > density;\r\n            }\r\n\r\n            if (particle.shouldFadeQuickly) {\r\n                // Quick fade out for particles marked to fade quickly\r\n                particle.opacity = Math.max(0, particle.opacity - deltaTime);\r\n            } else {\r\n                // Apply normal particle physics and animation\r\n                // Apply damping based on distance from original position\r\n                const dx = particle.originalX - particle.x;\r\n                const dy = particle.originalY - particle.y;\r\n                const distanceFromOrigin = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                // Damping factor increases with distance, creating a more natural motion\r\n                const dampingFactor = Math.max(0.95, 1 - distanceFromOrigin / (100 * MULTIPLIED_VAPORIZE_SPREAD));\r\n\r\n                // Add slight random motion to create a more organic feel\r\n                const randomSpread = MULTIPLIED_VAPORIZE_SPREAD * 3;\r\n                const spreadX = (Math.random() - 0.5) * randomSpread;\r\n                const spreadY = (Math.random() - 0.5) * randomSpread;\r\n\r\n                // Update velocities with damping and random motion\r\n                particle.velocityX = (particle.velocityX + spreadX + dx * 0.002) * dampingFactor;\r\n                particle.velocityY = (particle.velocityY + spreadY + dy * 0.002) * dampingFactor;\r\n\r\n                // Limit maximum velocity\r\n                const maxVelocity = MULTIPLIED_VAPORIZE_SPREAD * 2;\r\n                const currentVelocity = Math.sqrt(particle.velocityX * particle.velocityX + particle.velocityY * particle.velocityY);\r\n\r\n                if (currentVelocity > maxVelocity) {\r\n                    const scale = maxVelocity / currentVelocity;\r\n                    particle.velocityX *= scale;\r\n                    particle.velocityY *= scale;\r\n                }\r\n\r\n                // Update position\r\n                particle.x += particle.velocityX * deltaTime * 20;\r\n                particle.y += particle.velocityY * deltaTime * 10;\r\n\r\n                // Calculate fade rate based on vaporize duration\r\n                const baseFadeRate = 0.25;\r\n                const durationBasedFadeRate = baseFadeRate * (2000 / VAPORIZE_DURATION);\r\n\r\n                // Slower fade out for more persistence, scaled by duration\r\n                particle.opacity = Math.max(0, particle.opacity - deltaTime * durationBasedFadeRate);\r\n            }\r\n\r\n            // Check if this particle is still visible\r\n            if (particle.opacity > 0.01) {\r\n                allParticlesVaporized = false;\r\n            }\r\n        } else {\r\n            // If there are any particles not yet reached by the vaporize wave\r\n            allParticlesVaporized = false;\r\n        }\r\n    });\r\n\r\n    return allParticlesVaporized;\r\n};\r\n\r\nconst renderParticles = (ctx: CanvasRenderingContext2D, particles: Particle[], globalDpr: number) => {\r\n    ctx.save();\r\n    ctx.scale(globalDpr, globalDpr);\r\n\r\n    particles.forEach(particle => {\r\n        if (particle.opacity > 0) {\r\n            const color = particle.color.replace(/[\\d.]+\\)$/, `${particle.opacity})`);\r\n            ctx.fillStyle = color;\r\n            ctx.fillRect(particle.x / globalDpr, particle.y / globalDpr, 1, 1);\r\n        }\r\n    });\r\n\r\n    ctx.restore();\r\n};\r\n\r\nconst resetParticles = (particles: Particle[]) => {\r\n    particles.forEach(particle => {\r\n        particle.x = particle.originalX;\r\n        particle.y = particle.originalY;\r\n        particle.opacity = particle.originalAlpha;\r\n        particle.speed = 0;\r\n        particle.velocityX = 0;\r\n        particle.velocityY = 0;\r\n    });\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// CALCULATE VAPORIZE SPREAD\r\n// ------------------------------------------------------------ //\r\nconst calculateVaporizeSpread = (fontSize: number) => {\r\n    // Convert font size string to number if needed\r\n    const size = typeof fontSize === \"string\" ? parseInt(fontSize) : fontSize;\r\n\r\n    // Define our known points for interpolation\r\n    const points = [\r\n        { size: 20, spread: 0.2 },\r\n        { size: 50, spread: 0.5 },\r\n        { size: 100, spread: 1.5 }\r\n    ];\r\n\r\n    // Handle edge cases\r\n    if (size <= points[0].size) return points[0].spread;\r\n    if (size >= points[points.length - 1].size) return points[points.length - 1].spread;\r\n\r\n    // Find the two points to interpolate between\r\n    let i = 0;\r\n    while (i < points.length - 1 && points[i + 1].size < size) i++;\r\n\r\n    // Linear interpolation between the two closest points\r\n    const p1 = points[i];\r\n    const p2 = points[i + 1];\r\n\r\n    return p1.spread + (size - p1.size) * (p2.spread - p1.spread) / (p2.size - p1.size);\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// PARSE COLOR\r\n// ------------------------------------------------------------ //\r\n/**\r\n * Extracts RGB/RGBA values from a color string format\r\n * @param color - Color string (e.g. \"rgb(12, 250, 163)\")\r\n * @returns Valid RGBA color string\r\n */\r\nconst parseColor = (color: string) => {\r\n    // Try to match rgb/rgba pattern\r\n    const rgbMatch = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\r\n    const rgbaMatch = color.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\r\n\r\n    if (rgbaMatch) {\r\n        // If RGBA format\r\n        const [_, r, g, b, a] = rgbaMatch;\r\n        return `rgba(${r}, ${g}, ${b}, ${a})`;\r\n    } else if (rgbMatch) {\r\n        // If RGB format\r\n        const [_, r, g, b] = rgbMatch;\r\n        return `rgba(${r}, ${g}, ${b}, 1)`;\r\n    }\r\n\r\n    // Fallback to black if parsing fails\r\n    console.warn(\"Could not parse color:\", color);\r\n    return \"rgba(0, 0, 0, 1)\";\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// TRANSFORM VALUE\r\n// ------------------------------------------------------------ //\r\n/**\r\n * Maps a value from one range to another, optionally clamping the result.\r\n */\r\nfunction transformValue(input: number, inputRange: number[], outputRange: number[], clamp = false): number {\r\n    const [inputMin, inputMax] = inputRange;\r\n    const [outputMin, outputMax] = outputRange;\r\n\r\n    const progress = (input - inputMin) / (inputMax - inputMin);\r\n    let result = outputMin + progress * (outputMax - outputMin);\r\n\r\n    if (clamp) {\r\n        if (outputMax > outputMin) {\r\n            result = Math.min(Math.max(result, outputMin), outputMax);\r\n        } else {\r\n            result = Math.min(Math.max(result, outputMax), outputMin);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// ------------------------------------------------------------ //\r\n// INTERSECTION OBSERVER HOOK\r\n// ------------------------------------------------------------ //\r\n/**\r\n * Custom hook to check if an element is in the viewport\r\n */\r\nfunction useIsInView(ref: React.RefObject<HTMLElement>) {\r\n    const [isInView, setIsInView] = useState(false);\r\n\r\n    useEffect(() => {\r\n        if (!ref.current) return;\r\n\r\n        const observer = new IntersectionObserver(\r\n            ([entry]) => {\r\n                setIsInView(entry.isIntersecting);\r\n            },\r\n            { threshold: 0, rootMargin: '50px' }\r\n        );\r\n\r\n        observer.observe(ref.current);\r\n\r\n        return () => {\r\n            observer.disconnect();\r\n        };\r\n    }, [ref]);\r\n\r\n    return isInView;\r\n}\r\n","usedDeprecatedRules":[]}]
