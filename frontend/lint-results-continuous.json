[{"filePath":"C:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\components\\ui\\vapour-text-effect.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\priya\\OneDrive\\Desktop\\Corrupt sredibilty updated\\coorupt\\frontend\\src\\components\\ui\\vapour-text-effect.tsx:162:13\n  160 |         } else {\n  161 |             // When component goes out of view, reset to static state\n> 162 |             setAnimationState(\"static\");\n      |             ^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  163 |             if (animationFrameRef.current) {\n  164 |                 cancelAnimationFrame(animationFrameRef.current);\n  165 |                 animationFrameRef.current = null;","line":162,"column":13,"nodeType":null,"endLine":162,"endColumn":30},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'alignment', 'color', 'currentTextIndex', 'fontConfig.MULTIPLIED_VAPORIZE_SPREAD', 'fontConfig.font', 'mode', 'texts', and 'transformedDensity'. Either include them or remove the dependency array.","line":282,"column":8,"nodeType":"ArrayExpression","endLine":293,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [animationState, isInView, texts.length, direction, globalDpr, memoizedUpdateParticles, memoizedRenderParticles, animationDurations.FADE_IN_DURATION, animationDurations.WAIT_DURATION, animationDurations.VAPORIZE_DURATION, mode, fontConfig.font, fontConfig.MULTIPLIED_VAPORIZE_SPREAD, color, alignment, texts, currentTextIndex, transformedDensity]","fix":{"range":[10515,10833],"text":"[animationState, isInView, texts.length, direction, globalDpr, memoizedUpdateParticles, memoizedRenderParticles, animationDurations.FADE_IN_DURATION, animationDurations.WAIT_DURATION, animationDurations.VAPORIZE_DURATION, mode, fontConfig.font, fontConfig.MULTIPLIED_VAPORIZE_SPREAD, color, alignment, texts, currentTextIndex, transformedDensity]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":557,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":557,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19245,19248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19245,19248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":561,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19351,19354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19351,19354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport React, { useRef, useEffect, useState, createElement, useMemo, useCallback, memo } from \"react\";\r\n\r\nexport enum Tag {\r\n    H1 = \"h1\",\r\n    H2 = \"h2\",\r\n    H3 = \"h3\",\r\n    P = \"p\",\r\n}\r\n\r\ntype VaporizeTextCycleProps = {\r\n    texts: string[];\r\n    font?: {\r\n        fontFamily?: string;\r\n        fontSize?: string;\r\n        fontWeight?: number;\r\n    };\r\n    color?: string;\r\n    spread?: number;\r\n    density?: number;\r\n    animation?: {\r\n        vaporizeDuration?: number;\r\n        fadeInDuration?: number;\r\n        waitDuration?: number;\r\n    };\r\n    direction?: \"left-to-right\" | \"right-to-left\";\r\n    alignment?: \"left\" | \"center\" | \"right\";\r\n    tag?: Tag;\r\n    mode?: \"sequential\" | \"continuous\";\r\n};\r\n\r\ntype Particle = {\r\n    x: number;\r\n    y: number;\r\n    originalX: number;\r\n    originalY: number;\r\n    color: string;\r\n    opacity: number;\r\n    originalAlpha: number;\r\n    velocityX: number;\r\n    velocityY: number;\r\n    angle: number;\r\n    speed: number;\r\n    shouldFadeQuickly?: boolean;\r\n};\r\n\r\ntype TextBoundaries = {\r\n    left: number;\r\n    right: number;\r\n    width: number;\r\n};\r\n\r\ndeclare global {\r\n    interface HTMLCanvasElement {\r\n        textBoundaries?: TextBoundaries;\r\n    }\r\n}\r\n\r\nexport default function VaporizeTextCycle({\r\n    texts = [\"Next.js\", \"React\"],\r\n    font = {\r\n        fontFamily: \"sans-serif\",\r\n        fontSize: \"50px\",\r\n        fontWeight: 400,\r\n    },\r\n    color = \"rgb(255, 255, 255)\",\r\n    spread = 5,\r\n    density = 5,\r\n    animation = {\r\n        vaporizeDuration: 2,\r\n        fadeInDuration: 1,\r\n        waitDuration: 0.5,\r\n    },\r\n    direction = \"left-to-right\",\r\n    alignment = \"center\",\r\n    tag = Tag.P,\r\n    mode = \"sequential\",\r\n}: VaporizeTextCycleProps) {\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n    const wrapperRef = useRef<HTMLDivElement | null>(null);\r\n    const isInView = useIsInView(wrapperRef as React.RefObject<HTMLElement>);\r\n    const lastFontRef = useRef<string | null>(null);\r\n    const particlesRef = useRef<Particle[]>([]);\r\n    const animationFrameRef = useRef<number | null>(null);\r\n    const [currentTextIndex, setCurrentTextIndex] = useState(0);\r\n    const [animationState, setAnimationState] = useState<\"static\" | \"vaporizing\" | \"fadingIn\" | \"waiting\">(\"static\");\r\n    const vaporizeProgressRef = useRef(0);\r\n    const fadeOpacityRef = useRef(0);\r\n    const [wrapperSize, setWrapperSize] = useState({ width: 0, height: 0 });\r\n    const transformedDensity = transformValue(density, [0, 10], [0.3, 1], true);\r\n\r\n    // Calculate device pixel ratio\r\n    const globalDpr = useMemo(() => {\r\n        if (typeof window !== \"undefined\") {\r\n            return window.devicePixelRatio * 1.5 || 1;\r\n        }\r\n        return 1;\r\n    }, []);\r\n\r\n    // Memoize static styles\r\n    const wrapperStyle = useMemo(() => ({\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        pointerEvents: \"none\" as const,\r\n        position: \"relative\" as const,\r\n    }), []);\r\n\r\n    const canvasStyle = useMemo(() => ({\r\n        minWidth: \"30px\",\r\n        minHeight: \"20px\",\r\n        pointerEvents: \"none\" as const,\r\n    }), []);\r\n\r\n    // Memoize animation durations\r\n    const animationDurations = useMemo(() => ({\r\n        VAPORIZE_DURATION: (animation.vaporizeDuration ?? 2) * 1000,\r\n        FADE_IN_DURATION: (animation.fadeInDuration ?? 1) * 1000,\r\n        WAIT_DURATION: (animation.waitDuration ?? 0.5) * 1000,\r\n    }), [animation.vaporizeDuration, animation.fadeInDuration, animation.waitDuration]);\r\n\r\n    // Memoize font and spread calculations\r\n    const fontConfig = useMemo(() => {\r\n        const fontSize = parseInt(font.fontSize?.replace(\"px\", \"\") || \"50\");\r\n        const VAPORIZE_SPREAD = calculateVaporizeSpread(fontSize);\r\n        const MULTIPLIED_VAPORIZE_SPREAD = VAPORIZE_SPREAD * spread;\r\n        return {\r\n            fontSize,\r\n            VAPORIZE_SPREAD,\r\n            MULTIPLIED_VAPORIZE_SPREAD,\r\n            font: `${font.fontWeight ?? 400} ${fontSize * globalDpr}px ${font.fontFamily}`,\r\n        };\r\n    }, [font.fontSize, font.fontWeight, font.fontFamily, spread, globalDpr]);\r\n\r\n    // Memoize particle update function\r\n    const memoizedUpdateParticles = useCallback((particles: Particle[], vaporizeX: number, deltaTime: number) => {\r\n        return updateParticles(\r\n            particles,\r\n            vaporizeX,\r\n            deltaTime,\r\n            fontConfig.MULTIPLIED_VAPORIZE_SPREAD,\r\n            animationDurations.VAPORIZE_DURATION,\r\n            direction,\r\n            transformedDensity\r\n        );\r\n    }, [fontConfig.MULTIPLIED_VAPORIZE_SPREAD, animationDurations.VAPORIZE_DURATION, direction, transformedDensity]);\r\n\r\n    // Memoize render function\r\n    const memoizedRenderParticles = useCallback((ctx: CanvasRenderingContext2D, particles: Particle[]) => {\r\n        renderParticles(ctx, particles, globalDpr);\r\n    }, [globalDpr]);\r\n\r\n    // Start animation cycle when in view\r\n    useEffect(() => {\r\n        if (isInView) {\r\n            const startAnimationTimeout = setTimeout(() => {\r\n                setAnimationState(\"vaporizing\");\r\n            }, 0);\r\n            return () => clearTimeout(startAnimationTimeout);\r\n        } else {\r\n            // When component goes out of view, reset to static state\r\n            setAnimationState(\"static\");\r\n            if (animationFrameRef.current) {\r\n                cancelAnimationFrame(animationFrameRef.current);\r\n                animationFrameRef.current = null;\r\n            }\r\n        }\r\n    }, [isInView]);\r\n\r\n    // Animation loop - only run when in view\r\n    useEffect(() => {\r\n        if (!isInView) return;\r\n\r\n        let lastTime = performance.now();\r\n        let frameId: number;\r\n\r\n        const animate = (currentTime: number) => {\r\n            const deltaTime = (currentTime - lastTime) / 1000;\r\n            lastTime = currentTime;\r\n\r\n            const canvas = canvasRef.current;\r\n            const ctx = canvas?.getContext(\"2d\");\r\n\r\n            if (!canvas || !ctx || !particlesRef.current.length) {\r\n                frameId = requestAnimationFrame(animate);\r\n                return;\r\n            }\r\n\r\n            // Clear canvas only if we're going to draw\r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            // Update based on animation state\r\n            switch (animationState) {\r\n                case \"static\": {\r\n                    if (mode === \"continuous\") {\r\n                        drawSolidText(ctx, canvas, globalDpr, fontConfig.font, color, alignment, texts[currentTextIndex]);\r\n                    }\r\n                    memoizedRenderParticles(ctx, particlesRef.current);\r\n                    break;\r\n                }\r\n                case \"vaporizing\": {\r\n                    if (mode === \"continuous\") {\r\n                        drawSolidText(ctx, canvas, globalDpr, fontConfig.font, color, alignment, texts[currentTextIndex]);\r\n\r\n                        // Continuous emission logic\r\n                        updateParticlesContinuous(\r\n                            particlesRef.current,\r\n                            deltaTime,\r\n                            fontConfig.MULTIPLIED_VAPORIZE_SPREAD,\r\n                            animationDurations.VAPORIZE_DURATION,\r\n                            transformedDensity\r\n                        );\r\n                    } else {\r\n                        // Original sequential wave logic\r\n                        vaporizeProgressRef.current += deltaTime * 100 / (animationDurations.VAPORIZE_DURATION / 1000);\r\n\r\n                        const textBoundaries = canvas.textBoundaries;\r\n                        if (!textBoundaries) break;\r\n\r\n                        const progress = Math.min(100, vaporizeProgressRef.current);\r\n                        const vaporizeX = direction === \"left-to-right\"\r\n                            ? textBoundaries.left + textBoundaries.width * progress / 100\r\n                            : textBoundaries.right - textBoundaries.width * progress / 100;\r\n\r\n                        const allVaporized = memoizedUpdateParticles(particlesRef.current, vaporizeX, deltaTime);\r\n\r\n                        if (vaporizeProgressRef.current >= 100 && allVaporized) {\r\n                            setCurrentTextIndex(prevIndex => (prevIndex + 1) % texts.length);\r\n                            setAnimationState(\"fadingIn\");\r\n                            fadeOpacityRef.current = 0;\r\n                        }\r\n                    }\r\n\r\n                    memoizedRenderParticles(ctx, particlesRef.current);\r\n                    break;\r\n                }\r\n                case \"fadingIn\": {\r\n                    fadeOpacityRef.current += deltaTime * 1000 / animationDurations.FADE_IN_DURATION;\r\n\r\n                    // Use particles for fade-in\r\n                    ctx.save();\r\n                    ctx.scale(globalDpr, globalDpr);\r\n                    particlesRef.current.forEach(particle => {\r\n                        particle.x = particle.originalX;\r\n                        particle.y = particle.originalY;\r\n                        const opacity = Math.min(fadeOpacityRef.current, 1) * particle.originalAlpha;\r\n                        const color = particle.color.replace(/[\\d.]+\\)$/, `${opacity})`);\r\n                        ctx.fillStyle = color;\r\n                        ctx.fillRect(particle.x / globalDpr, particle.y / globalDpr, 1, 1);\r\n                    });\r\n                    ctx.restore();\r\n\r\n                    if (fadeOpacityRef.current >= 1) {\r\n                        setAnimationState(\"waiting\");\r\n                        setTimeout(() => {\r\n                            setAnimationState(\"vaporizing\");\r\n                            vaporizeProgressRef.current = 0;\r\n                            resetParticles(particlesRef.current);\r\n                        }, animationDurations.WAIT_DURATION);\r\n                    }\r\n                    break;\r\n                }\r\n                case \"waiting\": {\r\n                    if (mode === \"continuous\") {\r\n                        drawSolidText(ctx, canvas, globalDpr, fontConfig.font, color, alignment, texts[currentTextIndex]);\r\n                    }\r\n                    memoizedRenderParticles(ctx, particlesRef.current);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            frameId = requestAnimationFrame(animate);\r\n        };\r\n\r\n        frameId = requestAnimationFrame(animate);\r\n\r\n        return () => {\r\n            if (frameId) {\r\n                cancelAnimationFrame(frameId);\r\n            }\r\n        };\r\n    }, [\r\n        animationState,\r\n        isInView,\r\n        texts.length,\r\n        direction,\r\n        globalDpr,\r\n        memoizedUpdateParticles,\r\n        memoizedRenderParticles,\r\n        animationDurations.FADE_IN_DURATION,\r\n        animationDurations.WAIT_DURATION,\r\n        animationDurations.VAPORIZE_DURATION\r\n    ]);\r\n\r\n    useEffect(() => {\r\n        renderCanvas({\r\n            framerProps: {\r\n                texts,\r\n                font,\r\n                color,\r\n                alignment,\r\n            },\r\n            canvasRef: canvasRef as React.RefObject<HTMLCanvasElement>,\r\n            wrapperSize,\r\n            particlesRef,\r\n            globalDpr,\r\n            currentTextIndex,\r\n            transformedDensity,\r\n        });\r\n\r\n        const currentFont = font.fontFamily || \"sans-serif\";\r\n        return handleFontChange({\r\n            currentFont,\r\n            lastFontRef,\r\n            canvasRef: canvasRef as React.RefObject<HTMLCanvasElement>,\r\n            wrapperSize,\r\n            particlesRef,\r\n            globalDpr,\r\n            currentTextIndex,\r\n            transformedDensity,\r\n            framerProps: {\r\n                texts,\r\n                font,\r\n                color,\r\n                alignment,\r\n            },\r\n        });\r\n    }, [texts, font, color, alignment, wrapperSize, currentTextIndex, globalDpr, transformedDensity]);\r\n\r\n    // Handle resize\r\n    useEffect(() => {\r\n        const container = wrapperRef.current;\r\n        if (!container) return;\r\n\r\n        const resizeObserver = new ResizeObserver(entries => {\r\n            for (const entry of entries) {\r\n                const { width, height } = entry.contentRect;\r\n                setWrapperSize({ width, height });\r\n            }\r\n\r\n            renderCanvas({\r\n                framerProps: {\r\n                    texts,\r\n                    font,\r\n                    color,\r\n                    alignment,\r\n                },\r\n                canvasRef: canvasRef as React.RefObject<HTMLCanvasElement>,\r\n                wrapperSize: { width: container.clientWidth, height: container.clientHeight },\r\n                particlesRef,\r\n                globalDpr,\r\n                currentTextIndex,\r\n                transformedDensity,\r\n            });\r\n        });\r\n\r\n        resizeObserver.observe(container);\r\n        return () => {\r\n            resizeObserver.disconnect();\r\n        };\r\n    }, [texts, font, color, alignment, globalDpr, currentTextIndex, transformedDensity]);\r\n\r\n    // Initial size detection\r\n    useEffect(() => {\r\n        if (wrapperRef.current) {\r\n            const rect = wrapperRef.current.getBoundingClientRect();\r\n            setWrapperSize({\r\n                width: rect.width,\r\n                height: rect.height,\r\n            });\r\n        }\r\n    }, []);\r\n\r\n    return (\r\n        <div ref={wrapperRef} style={wrapperStyle}>\r\n            <canvas ref={canvasRef} style={canvasStyle} />\r\n            <SeoElement tag={tag} texts={texts} />\r\n        </div>\r\n    );\r\n}\r\n\r\n// ------------------------------------------------------------ //\r\n// SEO ELEMENT\r\n// ------------------------------------------------------------ //\r\nconst SeoElement = memo(({ tag = Tag.P, texts }: { tag: Tag, texts: string[] }) => {\r\n    const style = useMemo(() => ({\r\n        position: \"absolute\" as const,\r\n        width: \"0\",\r\n        height: \"0\",\r\n        overflow: \"hidden\",\r\n        userSelect: \"none\" as const,\r\n        pointerEvents: \"none\" as const,\r\n    }), []);\r\n\r\n    // Ensure tag is a valid HTML element string\r\n    const safeTag = Object.values(Tag).includes(tag) ? tag : \"p\";\r\n\r\n    return createElement(safeTag, { style }, texts?.join(\" \") ?? \"\");\r\n});\r\n\r\nSeoElement.displayName = \"SeoElement\";\r\n\r\n// ------------------------------------------------------------ //\r\n// FONT HANDLING\r\n// ------------------------------------------------------------ //\r\nconst handleFontChange = ({\r\n    currentFont,\r\n    lastFontRef,\r\n    canvasRef,\r\n    wrapperSize,\r\n    particlesRef,\r\n    globalDpr,\r\n    currentTextIndex,\r\n    transformedDensity,\r\n    framerProps,\r\n}: {\r\n    currentFont: string;\r\n    lastFontRef: React.MutableRefObject<string | null>;\r\n    canvasRef: React.RefObject<HTMLCanvasElement>;\r\n    wrapperSize: { width: number; height: number };\r\n    particlesRef: React.MutableRefObject<Particle[]>;\r\n    globalDpr: number;\r\n    currentTextIndex: number;\r\n    transformedDensity: number;\r\n    framerProps: VaporizeTextCycleProps;\r\n}) => {\r\n    if (currentFont !== lastFontRef.current) {\r\n        lastFontRef.current = currentFont;\r\n\r\n        // Re-render after 1 second to catch the loaded font\r\n        const timeoutId = setTimeout(() => {\r\n            cleanup({ canvasRef, particlesRef }); // Clean up before re-rendering\r\n            renderCanvas({\r\n                framerProps,\r\n                canvasRef,\r\n                wrapperSize,\r\n                particlesRef,\r\n                globalDpr,\r\n                currentTextIndex,\r\n                transformedDensity,\r\n            });\r\n        }, 1000);\r\n\r\n        return () => {\r\n            clearTimeout(timeoutId);\r\n            cleanup({ canvasRef, particlesRef });\r\n        };\r\n    }\r\n\r\n    return undefined;\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// CLEANUP\r\n// ------------------------------------------------------------ //\r\nconst cleanup = ({ canvasRef, particlesRef }: { canvasRef: React.RefObject<HTMLCanvasElement>; particlesRef: React.MutableRefObject<Particle[]> }) => {\r\n    // Clear canvas\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas?.getContext(\"2d\");\r\n\r\n    if (canvas && ctx) {\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    // Clear particles\r\n    if (particlesRef.current) {\r\n        particlesRef.current = [];\r\n    }\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// RENDER CANVAS\r\n// ------------------------------------------------------------ //\r\nconst renderCanvas = ({\r\n    framerProps,\r\n    canvasRef,\r\n    wrapperSize,\r\n    particlesRef,\r\n    globalDpr,\r\n    currentTextIndex,\r\n}: {\r\n    framerProps: VaporizeTextCycleProps;\r\n    canvasRef: React.RefObject<HTMLCanvasElement>;\r\n    wrapperSize: { width: number; height: number };\r\n    particlesRef: React.MutableRefObject<Particle[]>;\r\n    globalDpr: number;\r\n    currentTextIndex: number;\r\n    transformedDensity: number;\r\n}) => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas || !wrapperSize.width || !wrapperSize.height) return;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    const { width, height } = wrapperSize;\r\n\r\n    // Scale for retina/high DPI displays\r\n    canvas.style.width = `${width}px`;\r\n    canvas.style.height = `${height}px`;\r\n    canvas.width = Math.floor(width * globalDpr);\r\n    canvas.height = Math.floor(height * globalDpr);\r\n\r\n    // Parse font size\r\n    const fontSize = parseInt(framerProps.font?.fontSize?.replace(\"px\", \"\") || \"50\");\r\n    const font = `${framerProps.font?.fontWeight ?? 400} ${fontSize * globalDpr}px ${framerProps.font?.fontFamily ?? \"sans-serif\"}`;\r\n    const color = parseColor(framerProps.color ?? \"rgb(153, 153, 153)\");\r\n\r\n    // Calculate text position\r\n    let textX;\r\n    const textY = canvas.height / 2;\r\n    const currentText = framerProps.texts[currentTextIndex] || \"Next.js\";\r\n\r\n    if (framerProps.alignment === \"center\") {\r\n        textX = canvas.width / 2;\r\n    } else if (framerProps.alignment === \"left\") {\r\n        textX = 0;\r\n    } else {\r\n        textX = canvas.width;\r\n    }\r\n\r\n    // Create particles from the rendered text and get text boundaries\r\n    const { particles, textBoundaries } = createParticles(ctx, canvas, currentText, textX, textY, font, color, framerProps.alignment || \"left\");\r\n\r\n    // Store particles and text boundaries for animation\r\n    particlesRef.current = particles;\r\n    canvas.textBoundaries = textBoundaries;\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// PARTICLE SYSTEM\r\n// ------------------------------------------------------------ //\r\nconst createParticles = (\r\n    ctx: CanvasRenderingContext2D,\r\n    canvas: HTMLCanvasElement,\r\n    text: string,\r\n    textX: number,\r\n    textY: number,\r\n    font: string,\r\n    color: string,\r\n    alignment: \"left\" | \"center\" | \"right\"\r\n) => {\r\n    const particles = [];\r\n\r\n    // Clear any previous content\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Set text properties for sampling\r\n    ctx.fillStyle = color;\r\n    ctx.font = font;\r\n    ctx.textAlign = alignment;\r\n    ctx.textBaseline = \"middle\";\r\n    ctx.imageSmoothingQuality = \"high\";\r\n    ctx.imageSmoothingEnabled = true;\r\n\r\n    if ('fontKerning' in ctx) {\r\n        (ctx as Record<string, any>).fontKerning = \"normal\";\r\n    }\r\n\r\n    if ('textRendering' in ctx) {\r\n        (ctx as Record<string, any>).textRendering = \"geometricPrecision\";\r\n    }\r\n\r\n    // Calculate text boundaries\r\n    const metrics = ctx.measureText(text);\r\n    let textLeft;\r\n    const textWidth = metrics.width;\r\n\r\n    if (alignment === \"center\") {\r\n        textLeft = textX - textWidth / 2;\r\n    } else if (alignment === \"left\") {\r\n        textLeft = textX;\r\n    } else {\r\n        textLeft = textX - textWidth;\r\n    }\r\n\r\n    const textBoundaries = {\r\n        left: textLeft,\r\n        right: textLeft + textWidth,\r\n        width: textWidth,\r\n    };\r\n\r\n    // Render the text for sampling\r\n    ctx.fillText(text, textX, textY);\r\n\r\n    // Sample the rendered text\r\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    const data = imageData.data;\r\n\r\n    // Calculate sampling rate based on DPR and density to maintain consistent particle density\r\n    const baseDPR = 3; // Base DPR we're optimizing for\r\n    const currentDPR = canvas.width / parseInt(canvas.style.width);\r\n    const baseSampleRate = Math.max(1, Math.round(currentDPR / baseDPR));\r\n    const sampleRate = Math.max(1, Math.round(baseSampleRate)); // Adjust sample rate by density\r\n\r\n    // Sample the text pixels and create particles\r\n    for (let y = 0; y < canvas.height; y += sampleRate) {\r\n        for (let x = 0; x < canvas.width; x += sampleRate) {\r\n            const index = (y * canvas.width + x) * 4;\r\n            const alpha = data[index + 3];\r\n\r\n            if (alpha > 0) {\r\n                // Remove density from opacity calculation\r\n                const originalAlpha = alpha / 255 * (sampleRate / currentDPR);\r\n                const particle = {\r\n                    x,\r\n                    y,\r\n                    originalX: x,\r\n                    originalY: y,\r\n                    color: `rgba(${data[index]}, ${data[index + 1]}, ${data[index + 2]}, ${originalAlpha})`,\r\n                    opacity: originalAlpha,\r\n                    originalAlpha,\r\n                    // Animation properties\r\n                    velocityX: 0,\r\n                    velocityY: 0,\r\n                    angle: 0,\r\n                    speed: 0,\r\n                };\r\n\r\n                particles.push(particle);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Clear the canvas after sampling\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    return { particles, textBoundaries };\r\n};\r\n\r\n// Helper functions for particle animation\r\nconst updateParticles = (\r\n    particles: Particle[],\r\n    vaporizeX: number,\r\n    deltaTime: number,\r\n    MULTIPLIED_VAPORIZE_SPREAD: number,\r\n    VAPORIZE_DURATION: number,\r\n    direction: string,\r\n    density: number\r\n) => {\r\n    let allParticlesVaporized = true;\r\n\r\n    particles.forEach(particle => {\r\n        // Only animate particles that have been \"vaporized\"\r\n        const shouldVaporize = direction === \"left-to-right\"\r\n            ? particle.originalX <= vaporizeX\r\n            : particle.originalX >= vaporizeX;\r\n\r\n        if (shouldVaporize) {\r\n            // When a particle is first vaporized, determine if it should fade quickly based on density\r\n            if (particle.speed === 0) {\r\n                // Initialize particle motion when first vaporized\r\n                particle.angle = Math.random() * Math.PI * 2;\r\n                particle.speed = (Math.random() * 1 + 0.5) * MULTIPLIED_VAPORIZE_SPREAD;\r\n                particle.velocityX = Math.cos(particle.angle) * particle.speed;\r\n                particle.velocityY = Math.sin(particle.angle) * particle.speed;\r\n\r\n                // Determine if particle should fade quickly based on density\r\n                // density of 1 means all particles animate normally\r\n                // density of 0.5 means 50% of particles fade quickly\r\n                particle.shouldFadeQuickly = Math.random() > density;\r\n            }\r\n\r\n            if (particle.shouldFadeQuickly) {\r\n                // Quick fade out for particles marked to fade quickly\r\n                particle.opacity = Math.max(0, particle.opacity - deltaTime);\r\n            } else {\r\n                // Apply normal particle physics and animation\r\n                // Apply damping based on distance from original position\r\n                const dx = particle.originalX - particle.x;\r\n                const dy = particle.originalY - particle.y;\r\n                const distanceFromOrigin = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                // Damping factor increases with distance, creating a more natural motion\r\n                const dampingFactor = Math.max(0.95, 1 - distanceFromOrigin / (100 * MULTIPLIED_VAPORIZE_SPREAD));\r\n\r\n                // Add slight random motion to create a more organic feel\r\n                const randomSpread = MULTIPLIED_VAPORIZE_SPREAD * 3;\r\n                const spreadX = (Math.random() - 0.5) * randomSpread;\r\n                const spreadY = (Math.random() - 0.5) * randomSpread;\r\n\r\n                // Update velocities with damping and random motion\r\n                particle.velocityX = (particle.velocityX + spreadX + dx * 0.002) * dampingFactor;\r\n                particle.velocityY = (particle.velocityY + spreadY + dy * 0.002) * dampingFactor;\r\n\r\n                // Limit maximum velocity\r\n                const maxVelocity = MULTIPLIED_VAPORIZE_SPREAD * 2;\r\n                const currentVelocity = Math.sqrt(particle.velocityX * particle.velocityX + particle.velocityY * particle.velocityY);\r\n\r\n                if (currentVelocity > maxVelocity) {\r\n                    const scale = maxVelocity / currentVelocity;\r\n                    particle.velocityX *= scale;\r\n                    particle.velocityY *= scale;\r\n                }\r\n\r\n                // Update position\r\n                particle.x += particle.velocityX * deltaTime * 20;\r\n                particle.y += particle.velocityY * deltaTime * 10;\r\n\r\n                // Calculate fade rate based on vaporize duration\r\n                const baseFadeRate = 0.25;\r\n                const durationBasedFadeRate = baseFadeRate * (2000 / VAPORIZE_DURATION);\r\n\r\n                // Slower fade out for more persistence, scaled by duration\r\n                particle.opacity = Math.max(0, particle.opacity - deltaTime * durationBasedFadeRate);\r\n            }\r\n\r\n            // Check if this particle is still visible\r\n            if (particle.opacity > 0.01) {\r\n                allParticlesVaporized = false;\r\n            }\r\n        } else {\r\n            // If there are any particles not yet reached by the vaporize wave\r\n            allParticlesVaporized = false;\r\n        }\r\n    });\r\n\r\n    return allParticlesVaporized;\r\n};\r\n\r\nconst renderParticles = (ctx: CanvasRenderingContext2D, particles: Particle[], globalDpr: number) => {\r\n    ctx.save();\r\n    ctx.scale(globalDpr, globalDpr);\r\n\r\n    particles.forEach(particle => {\r\n        if (particle.opacity > 0) {\r\n            const color = particle.color.replace(/[\\d.]+\\)$/, `${particle.opacity})`);\r\n            ctx.fillStyle = color;\r\n            ctx.fillRect(particle.x / globalDpr, particle.y / globalDpr, 1, 1);\r\n        }\r\n    });\r\n\r\n    ctx.restore();\r\n};\r\n\r\nconst resetParticles = (particles: Particle[]) => {\r\n    particles.forEach(particle => {\r\n        particle.x = particle.originalX;\r\n        particle.y = particle.originalY;\r\n        particle.opacity = particle.originalAlpha;\r\n        particle.speed = 0;\r\n        particle.velocityX = 0;\r\n        particle.velocityY = 0;\r\n    });\r\n};\r\n\r\nconst updateParticlesContinuous = (\r\n    particles: Particle[],\r\n    deltaTime: number,\r\n    MULTIPLIED_VAPORIZE_SPREAD: number,\r\n    VAPORIZE_DURATION: number,\r\n    density: number\r\n) => {\r\n    // Chance for a pixel to \"emit\" a particle per update\r\n    const baseEmissionChance = 0.5; // High base chance for continuous flow\r\n    const emissionChance = baseEmissionChance * density;\r\n\r\n    particles.forEach(particle => {\r\n        // If particle is stationary, chance to activate it\r\n        if (particle.speed === 0) {\r\n            if (Math.random() < emissionChance * deltaTime) {\r\n                // Initialize sophisticated reference physics\r\n                particle.angle = Math.PI * 1.5 + (Math.random() - 0.5) * 1.5; // Bias upwards\r\n                particle.speed = (Math.random() * 1.2 + 0.6) * MULTIPLIED_VAPORIZE_SPREAD;\r\n                particle.velocityX = Math.cos(particle.angle) * particle.speed;\r\n                particle.velocityY = Math.sin(particle.angle) * particle.speed;\r\n                particle.shouldFadeQuickly = Math.random() > 0.8; // Some particles die faster\r\n            }\r\n        }\r\n\r\n        // If particle is active, update with reference physics\r\n        if (particle.speed > 0) {\r\n            if (particle.shouldFadeQuickly && particle.opacity < 0.3) {\r\n                particle.opacity = Math.max(0, particle.opacity - deltaTime * 1.5);\r\n            } else {\r\n                const dx = particle.originalX - particle.x;\r\n                const dy = particle.originalY - particle.y;\r\n                const distanceFromOrigin = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                // Reference damping factor\r\n                const dampingFactor = Math.max(0.95, 1 - distanceFromOrigin / (150 * MULTIPLIED_VAPORIZE_SPREAD));\r\n\r\n                // Organic random spread\r\n                const randomSpread = MULTIPLIED_VAPORIZE_SPREAD * 4;\r\n                const spreadX = (Math.random() - 0.5) * randomSpread;\r\n                const spreadY = (Math.random() - 0.5) * randomSpread;\r\n\r\n                // Update velocities with damping and organic motion\r\n                particle.velocityX = (particle.velocityX + spreadX + dx * 0.001) * dampingFactor;\r\n                particle.velocityY = (particle.velocityY + spreadY + dy * 0.001) * dampingFactor;\r\n\r\n                // Limit max velocity\r\n                const maxVelocity = MULTIPLIED_VAPORIZE_SPREAD * 3;\r\n                const currentVelocity = Math.sqrt(particle.velocityX * particle.velocityX + particle.velocityY * particle.velocityY);\r\n                if (currentVelocity > maxVelocity) {\r\n                    const scale = maxVelocity / currentVelocity;\r\n                    particle.velocityX *= scale;\r\n                    particle.velocityY *= scale;\r\n                }\r\n\r\n                // Update position (reference scaling)\r\n                particle.x += particle.velocityX * deltaTime * 25;\r\n                particle.y += particle.velocityY * deltaTime * 15;\r\n\r\n                // Ethereal fade logic\r\n                const fadeRate = 0.3 * (2000 / VAPORIZE_DURATION);\r\n                particle.opacity = Math.max(0, particle.opacity - deltaTime * fadeRate);\r\n            }\r\n\r\n            // Once faded out, reset for re-emission\r\n            if (particle.opacity <= 0.05) {\r\n                particle.x = particle.originalX;\r\n                particle.y = particle.originalY;\r\n                particle.opacity = particle.originalAlpha;\r\n                particle.speed = 0;\r\n                particle.velocityX = 0;\r\n                particle.velocityY = 0;\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\nconst drawSolidText = (\r\n    ctx: CanvasRenderingContext2D,\r\n    canvas: HTMLCanvasElement,\r\n    globalDpr: number,\r\n    font: string,\r\n    color: string,\r\n    alignment: \"left\" | \"center\" | \"right\",\r\n    text: string\r\n) => {\r\n    ctx.save();\r\n    ctx.scale(globalDpr, globalDpr);\r\n    ctx.fillStyle = color;\r\n    ctx.font = font.replace(`${parseInt(font) * globalDpr}px`, `${parseInt(font)}px`);\r\n    ctx.textAlign = alignment;\r\n    ctx.textBaseline = \"middle\";\r\n\r\n    let textX;\r\n    if (alignment === \"center\") textX = canvas.width / (2 * globalDpr);\r\n    else if (alignment === \"left\") textX = 0;\r\n    else textX = canvas.width / globalDpr;\r\n\r\n    ctx.fillText(text, textX, canvas.height / (2 * globalDpr));\r\n    ctx.restore();\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// CALCULATE VAPORIZE SPREAD\r\n// ------------------------------------------------------------ //\r\nconst calculateVaporizeSpread = (fontSize: number) => {\r\n    // Convert font size string to number if needed\r\n    const size = typeof fontSize === \"string\" ? parseInt(fontSize) : fontSize;\r\n\r\n    // Define our known points for interpolation\r\n    const points = [\r\n        { size: 20, spread: 0.2 },\r\n        { size: 50, spread: 0.5 },\r\n        { size: 100, spread: 1.5 }\r\n    ];\r\n\r\n    // Handle edge cases\r\n    if (size <= points[0].size) return points[0].spread;\r\n    if (size >= points[points.length - 1].size) return points[points.length - 1].spread;\r\n\r\n    // Find the two points to interpolate between\r\n    let i = 0;\r\n    while (i < points.length - 1 && points[i + 1].size < size) i++;\r\n\r\n    // Linear interpolation between the two closest points\r\n    const p1 = points[i];\r\n    const p2 = points[i + 1];\r\n\r\n    return p1.spread + (size - p1.size) * (p2.spread - p1.spread) / (p2.size - p1.size);\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// PARSE COLOR\r\n// ------------------------------------------------------------ //\r\n/**\r\n * Extracts RGB/RGBA values from a color string format\r\n * @param color - Color string (e.g. \"rgb(12, 250, 163)\")\r\n * @returns Valid RGBA color string\r\n */\r\nconst parseColor = (color: string) => {\r\n    // Try to match rgb/rgba pattern\r\n    const rgbMatch = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\r\n    const rgbaMatch = color.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\r\n\r\n    if (rgbaMatch) {\r\n        // If RGBA format\r\n        const [, r, g, b, a] = rgbaMatch;\r\n        return `rgba(${r}, ${g}, ${b}, ${a})`;\r\n    } else if (rgbMatch) {\r\n        // If RGB format\r\n        const [, r, g, b] = rgbMatch;\r\n        return `rgba(${r}, ${g}, ${b}, 1)`;\r\n    }\r\n\r\n    // Fallback to black if parsing fails\r\n    console.warn(\"Could not parse color:\", color);\r\n    return \"rgba(0, 0, 0, 1)\";\r\n};\r\n\r\n// ------------------------------------------------------------ //\r\n// TRANSFORM VALUE\r\n// ------------------------------------------------------------ //\r\n/**\r\n * Maps a value from one range to another, optionally clamping the result.\r\n */\r\nfunction transformValue(input: number, inputRange: number[], outputRange: number[], clamp = false): number {\r\n    const [inputMin, inputMax] = inputRange;\r\n    const [outputMin, outputMax] = outputRange;\r\n\r\n    const progress = (input - inputMin) / (inputMax - inputMin);\r\n    let result = outputMin + progress * (outputMax - outputMin);\r\n\r\n    if (clamp) {\r\n        if (outputMax > outputMin) {\r\n            result = Math.min(Math.max(result, outputMin), outputMax);\r\n        } else {\r\n            result = Math.min(Math.max(result, outputMax), outputMin);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// ------------------------------------------------------------ //\r\n// INTERSECTION OBSERVER HOOK\r\n// ------------------------------------------------------------ //\r\n/**\r\n * Custom hook to check if an element is in the viewport\r\n */\r\nfunction useIsInView(ref: React.RefObject<HTMLElement>) {\r\n    const [isInView, setIsInView] = useState(false);\r\n\r\n    useEffect(() => {\r\n        if (!ref.current) return;\r\n\r\n        const observer = new IntersectionObserver(\r\n            ([entry]) => {\r\n                setIsInView(entry.isIntersecting);\r\n            },\r\n            { threshold: 0, rootMargin: '50px' }\r\n        );\r\n\r\n        observer.observe(ref.current);\r\n\r\n        return () => {\r\n            observer.disconnect();\r\n        };\r\n    }, [ref]);\r\n\r\n    return isInView;\r\n}\r\n","usedDeprecatedRules":[]}]
